\section{Описание}
Требуется написать реализацию алгоритма поразрядной сортировки.

Основная идея заключается в применении устойчивой (элементы с одним и тем же значением находятся в том же порядке в выходном массиве, что и во входном) сортировки элементов по разрядам (в данном случае - от младшего разряда к старшему - LSD).

Применяемая устойчивая сортировка - сортировка подсчетом, идея которой - определение для каждого элемента $x$ количества элементов, которые меньше $x$ и размещение элемента $x$ в подходящей для него позиции.

Псевдокод функции сортировки подсчетом в общем случае:
\begin{lstlisting}
	CountingSort(A, B, k):
		C[0...k]
		for i = 0 to k:
			C[i] = 0
		for j = 1 to len(A):
			C[A[j]]++
		for i = 1 to k:
			C[i] = C[i] + C[i-1]
		for j = len(A) downto 1:
			B[C[A[j]]] = A[j]
			C[A[j]]--
\end{lstlisting}

Общее время сортировки и количество используемой памяти - $O(k + n)$, где $k$ - максимальный элемент входного массива, $n$ - количество элементов во входном массиве.

Псевдокод поразрядной сортировки в общем случае:
\begin{lstlisting}
	RadixSort(A, d):
		for i = 1 to d:
			some-stable-sort(A, i)
\end{lstlisting}

Время работы - $O(d(n + k))$ в случае задачи сортировки $n$ $d-$значных объектов, составные части которого принимают одно из $k$ возможных значений.

Если $d$ - константа, а $k = O(n)$, то время работы алгоритма поразрядной сортировки линейно зависит от количества входных элементов. 

В контексте условия задачи и применения поразрядной сортировки нам известен аргумент $k = 16$ - количество значений разряда (т. к. шестнадцатеричные числа). В коде этот аргумент заменяется аргументом $pos$ - позиции (разряду), по которой необходимо провести сортировку.

\pagebreak

\section{Исходный код}
Создадим вектор элементов типа "ключ-значение" (вектор Item); заполним его содержимым непустых строк потока ввода; также создадим вектор результата (который будет выводиться после исполнения функции сортировки). 

Вызовем функцию RadixSort, которая вызывает поразрядно функцию CountingSort и присваивает элементам исходного массива значения элементов массива, отсортированного по текущему разряду ключей Item.

RadixSort принимает ссылки на вектор входных данных и результирующий вектор. CountingSort принимает помимо вышеперечисленных аргументов позицию (разряд), по которой будет происходить сортировка ключей элементов.
Функции имеют тип void, так как они изменяют исходные массивы-аргументы функций сортировок.

Небольшая особенность задачи заключается в прерывности значений символов строки в ASCII: с 48 по 57 позицию находятся цифры, а с 97 по 102 - буквы диапазона 'a'-'f'. Для корректного подсчета количества этих букв в каждом ключе на определенной позиции используется функция to\_int().

Также для быстродействия была отключена синхронизация потоков ввода-вывода стандартной библиотеки C и C++.

После выполнения сортировки выводим полученный результирующий вектор. 

\begin{lstlisting}[language=C++]
	#include <bits/stdc++.h>
	
	using namespace std;
	
	const int MD5 = 16;
	
	struct Item {
		string key;
		uint64_t val;
	};
	
	int to_int(char c) {
		if (48 <= c && c <= 57) {
			return c - 48;
		} else if (97 <= c && c <= 102) {
			return c - 97 + 10;
		} else {
			return 0;
		}
	}
	
	void CountingSort(vector<Item>& A, vector<Item>& B, int pos) {
		vector<int> count(MD5, 0);
		for (size_t i = 0; i < A.size(); ++i) {
			++count[to_int(A[i].key[pos])];
		}
		
		for (size_t i = 1; i < MD5; ++i) {
			count[i] += count[i - 1];
		}
		
		for (int i = static_cast<int>(A.size()) - 1; i >= 0; --i) {
			size_t p = count[to_int(A[i].key[pos])] - 1;
			B[p] = A[i];
			--count[to_int(A[i].key[pos])];
		}
		
	}
	
	void RadixSort(vector<Item>& A, vector<Item>& B) {
		int maxLength = 32;
		for (int i = maxLength - 1; i >= 0; i--) {
			CountingSort(A, B, i);
			for (size_t j = 0; j < A.size(); ++j) {
				A[j] = B[j];
			}
		}
	}
	
	int main() {
		ios::sync_with_stdio(false);
		cin.tie(0);
		
		vector<Item> v;
		Item curr;
		
		while (cin >> curr.key >> curr.val) {
			v.push_back(curr);
		}
		
		vector<Item> result(v.size());
		RadixSort(v, result);
		
		for (size_t i = 0; i < result.size(); ++i) {
			cout << result[i].key << '\t' << result[i].val << '\n';
		}
		
		return 0;
	}
	
	
\end{lstlisting}


\pagebreak

\section{Консоль}
\begin{alltt}
	[anton@home lab1]$ make
	g++ -O2 -lm -fno-stack-limit -std=c++20 -x c++ main.cpp -o main
	[anton@home lab1]$ cat test.txt 
	00000000000000000000000000000000        13207862122685464576
	ffffffffffffffffffffffffffffffff        7670388314707853312
	00000000000000000000000000000000        4588010303972900864
	ffffffffffffffffffffffffffffffff        12992997081104908288
	[anton@home lab1]$ ./main < test.txt
	00000000000000000000000000000000        13207862122685464576
	00000000000000000000000000000000        4588010303972900864
	ffffffffffffffffffffffffffffffff        7670388314707853312
	ffffffffffffffffffffffffffffffff        12992997081104908288
	
\end{alltt}
\pagebreak